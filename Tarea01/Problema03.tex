\textbf{\textcolor{blue}{3.}} Preparata se encuentra haciendo el programa "X", el programa "X" es un juego para resolver un cubo Rubik, el usuario analiza el estado de  un cubo Rubik en tres dimensiones y con base en su criterio  elije una de las operaciones $a_1 ... a_n$, para modificar el estado del cubo, Preparata sabe que estas operaciones tienen "inversa" es decir si la operación $a_1$ nos lleva del estado $e_1$ al estado $e_2$ entonces la inversa de la operación $a_1$ nos regresa al estado $e_1$, el ya tiene programadas todas las operaciones con sus respectivas operaciones inversas, pero no sabe como implementar la transición y el regreso de los estados para que el usuario pueda hacer una operación o deshacerla, el usuario también puede realizar varias operaciones y deshacerlas todas o una parte de ellas, además si ya deshizo un conjunto de operaciones puede volver a recrearlas sin necesidad de volver a pensar en ellas.
    
El cree que una estructura de datos le podría ayudar con esto. Ayudale a Preparata a descubrir la estructura de datos que necesita y explica detalladamente como  implementar la transición y el regreso de los estados, la complejidad de tu solución debe ser de orden $O(1)$ para deshacer una operación o para recrearla. Nota: Las operaciones tienen orden. (2 puntos)\newline

$\rhd$\textbf{Solución.} Para este problema podemos hacer uso de $2$ pilas cómo estructura
de datos para el almacenamiento de las operaciones aplicadas ¿De qué manera?
\begin{enumerate}
\item En la pila, digamos $P_1$, insertamos las operaciones. Sin en algún momento requerimos
  \textit{deshacer} la operación más reciente sacamos el tope de la pila. Si requerimos regresarnos
  $i$-operaciones, entonces sacamos $i$ topes de $P_1$ y regresamos al estado partícular que
  queremos.
\item ¿Cómo hacemos que tenga memoria? Los elementos que saquemos de $P_1$ los ingresamos a la
  segunda pila, digamos $P_2$, si en algún momento necesitamos recordar la operación que deshicimos
  basta consultar el tope de $P_2$.
\end{enumerate}
\textit{Análisis de complejidad.} A continuación se desglosa la complejidad de operaciones:
\begin{enumerate}
\item Insertar en la pila nos cuesta $\mathcal{O}(1)$.
\item Sacar el tope de la pila nos cuesta $\mathcal{O}(1)$.
\end{enumerate}
En total, nuestra complejidad es del orden $\mathcal{O}(1)$ por \textit{deshacer} o \textit{rehacer}
una operación.
\hfill $\lhd$
